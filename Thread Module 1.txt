ğŸ”„ Training Flow
Letâ€™s begin with Module 1 and work our way up. For each module, youâ€™ll get:

ğŸ“˜ Concept explanation

ğŸ”§ Code snippets

âœ… Exercises

ğŸš€ Challenges



ğŸ”¸ 1.1 Creating Threads in Java
There are 3 main ways to create threads in Java:

âœ… 1.1.1 Extending Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Running thread: " + Thread.currentThread().getName());
    }
}

public class ThreadExample1 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // start() creates a new thread and calls run()
    }
}


âœ… 1.1.2 Implementing Runnable (preferred way)
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable executed by: " + Thread.currentThread().getName());
    }
}

public class ThreadExample2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
âœ… 1.1.3 Using Callable and ExecutorService

import java.util.concurrent.*;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<String> task = () -> {
            Thread.sleep(1000);
            return "Task executed by: " + Thread.currentThread().getName();
        };

        Future<String> result = executor.submit(task);
        System.out.println(result.get()); // blocks until task completes

        executor.shutdown();
    }
}


| Criteria                            | `extends Thread` | `implements Runnable`  |
| ----------------------------------- | ---------------- | ---------------------- |
| Need to override only `run()`       | âœ… Yes            | âœ… Yes                  |
| Need to extend another class        | âŒ No             | âœ… Yes                  |
| Separation of logic & threading     | âŒ No             | âœ… Yes                  |
| Preferred in thread pool/executors  | âŒ Not ideal      | âœ… Highly preferred     |
| Used in modern, clean architectures | âŒ Rare           | âœ… Common and preferred |



Difference B/W Callable and Runnable

| Feature                       | `Runnable`                           | `Callable<V>`                        |
| ----------------------------- | ------------------------------------ | ------------------------------------ |
| **Returns a result?**         | âŒ No                                 | âœ… Yes                                |
| **Throws checked exception?** | âŒ No                                 | âœ… Yes                                |
| **Method to override**        | `public void run()`                  | `public V call()`                    |
| **Used with**                 | `Thread`, `ExecutorService.submit()` | `ExecutorService.submit()`, `Future` |
| **Result handling**           | No result                            | Use `Future.get()` to get the result |




ğŸ”¸ 1.2 Thread Lifecycle
A thread moves through these states:

NEW â†’ RUNNABLE â†’ RUNNING â†’ TERMINATED
             â†˜ WAITING / BLOCKED / TIMED_WAITING â†—
State			Meaning
NEW				Thread object created
RUNNABLE		Ready to run, waiting for CPU
RUNNING			Currently executing
BLOCKED			Waiting for a monitor lock
WAITING			Waiting indefinitely (e.g. join())
TIMED_WAITING	Waiting for a limited time (e.g. sleep)
TERMINATED		Finished execution

ğŸ”§ Example: Creating 3 Threads Printing Messages

class MessagePrinter implements Runnable {
    private final String message;

    public MessagePrinter(String message) {
        this.message = message;
    }

    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + message + " " + i);
        }
    }
}

public class ThreadRunner {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MessagePrinter("Hello"));
        Thread t2 = new Thread(new MessagePrinter("World"));
        Thread t3 = new Thread(new MessagePrinter("Java"));

        t1.start();
        t2.start();
        t3.start();
    }
}
ğŸ” Note: The output may not be in order. That's the nature of concurrency!


Here's a clear breakdown of Callable, Future, CompletableFuture, and ExecutorService in Java, with purpose, when to use, and how they relate.

ğŸ§© 1. Callable
A task that returns a result and may throw an exception.

ğŸ”¹ Similar to Runnable, but it returns a value.

ğŸ”¹ Used for tasks where the result is needed after execution.

Callable<String> task = () -> "Hello from Callable";
ğŸ§© 2. Future
A handle to the result of an asynchronous computation.

ğŸ”¹ Returned by submitting a Callable to an ExecutorService.

ğŸ”¹ Allows you to:

Get the result with get() (blocking call).

Cancel the task.

Check if the task is done.

ExecutorService executor = Executors.newFixedThreadPool(2);
Future<String> future = executor.submit(() -> "Result");
String result = future.get(); // waits for result
ğŸ§© 3. CompletableFuture
An enhancement over Future that supports non-blocking, chaining, and composition.

ğŸ”¹ Part of Java 8+.

ğŸ”¹ Supports:

supplyAsync() or runAsync() for async execution.

Callback chains: thenApply, thenAccept, thenCombine, etc.

Non-blocking execution: whenComplete, exceptionally, etc.

CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenApply(result -> result + " World");

future.thenAccept(System.out::println); // Prints: Hello World
ğŸ§© 4. ExecutorService
A thread pool manager that executes Runnable or Callable tasks asynchronously.

ğŸ”¹ Provides thread reuse.

ğŸ”¹ Avoids manual thread management (new Thread(...)).

ğŸ”¹ You submit tasks, and it returns Future (for Callable) or void (for Runnable).

ğŸ”¹ Must call shutdown() to stop accepting tasks and clean up.

ExecutorService executor = Executors.newFixedThreadPool(3);
executor.submit(() -> System.out.println("Task running"));
executor.shutdown();


| Use Case                                                              | Use This                                                                |
| --------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Need to return a result from a background task                        | `Callable` + `Future`                                                   |
| Need to run async tasks and chain results or handle errors gracefully | `CompletableFuture`                                                     |
| Want to manage a thread pool and submit tasks                         | `ExecutorService`                                                       |
| Need fine-grained control over async task lifecycle                   | Combine `ExecutorService` with `Callable/Future` or `CompletableFuture` |




âœ… Your Exercise:
Write a program that starts 5 threads.

Each thread should:

Print its name

Sleep for 500ms between prints

Repeat this 3 times

Would you like me to generate the solution for this challenge or would you like to try it and Iâ€™ll review?









Ask ChatGPT
