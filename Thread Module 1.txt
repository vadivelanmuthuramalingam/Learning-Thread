🔄 Training Flow
Let’s begin with Module 1 and work our way up. For each module, you’ll get:

📘 Concept explanation

🔧 Code snippets

✅ Exercises

🚀 Challenges



🔸 1.1 Creating Threads in Java
There are 3 main ways to create threads in Java:

✅ 1.1.1 Extending Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Running thread: " + Thread.currentThread().getName());
    }
}

public class ThreadExample1 {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // start() creates a new thread and calls run()
    }
}


✅ 1.1.2 Implementing Runnable (preferred way)
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable executed by: " + Thread.currentThread().getName());
    }
}

public class ThreadExample2 {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}
✅ 1.1.3 Using Callable and ExecutorService

import java.util.concurrent.*;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<String> task = () -> {
            Thread.sleep(1000);
            return "Task executed by: " + Thread.currentThread().getName();
        };

        Future<String> result = executor.submit(task);
        System.out.println(result.get()); // blocks until task completes

        executor.shutdown();
    }
}


| Criteria                            | `extends Thread` | `implements Runnable`  |
| ----------------------------------- | ---------------- | ---------------------- |
| Need to override only `run()`       | ✅ Yes            | ✅ Yes                  |
| Need to extend another class        | ❌ No             | ✅ Yes                  |
| Separation of logic & threading     | ❌ No             | ✅ Yes                  |
| Preferred in thread pool/executors  | ❌ Not ideal      | ✅ Highly preferred     |
| Used in modern, clean architectures | ❌ Rare           | ✅ Common and preferred |



Difference B/W Callable and Runnable

| Feature                       | `Runnable`                           | `Callable<V>`                        |
| ----------------------------- | ------------------------------------ | ------------------------------------ |
| **Returns a result?**         | ❌ No                                 | ✅ Yes                                |
| **Throws checked exception?** | ❌ No                                 | ✅ Yes                                |
| **Method to override**        | `public void run()`                  | `public V call()`                    |
| **Used with**                 | `Thread`, `ExecutorService.submit()` | `ExecutorService.submit()`, `Future` |
| **Result handling**           | No result                            | Use `Future.get()` to get the result |




🔸 1.2 Thread Lifecycle
A thread moves through these states:

NEW → RUNNABLE → RUNNING → TERMINATED
             ↘ WAITING / BLOCKED / TIMED_WAITING ↗
State			Meaning
NEW				Thread object created
RUNNABLE		Ready to run, waiting for CPU
RUNNING			Currently executing
BLOCKED			Waiting for a monitor lock
WAITING			Waiting indefinitely (e.g. join())
TIMED_WAITING	Waiting for a limited time (e.g. sleep)
TERMINATED		Finished execution

🔧 Example: Creating 3 Threads Printing Messages

class MessagePrinter implements Runnable {
    private final String message;

    public MessagePrinter(String message) {
        this.message = message;
    }

    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + message + " " + i);
        }
    }
}

public class ThreadRunner {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MessagePrinter("Hello"));
        Thread t2 = new Thread(new MessagePrinter("World"));
        Thread t3 = new Thread(new MessagePrinter("Java"));

        t1.start();
        t2.start();
        t3.start();
    }
}
🔍 Note: The output may not be in order. That's the nature of concurrency!


Here's a clear breakdown of Callable, Future, CompletableFuture, and ExecutorService in Java, with purpose, when to use, and how they relate.

🧩 1. Callable
A task that returns a result and may throw an exception.

🔹 Similar to Runnable, but it returns a value.

🔹 Used for tasks where the result is needed after execution.

Callable<String> task = () -> "Hello from Callable";
🧩 2. Future
A handle to the result of an asynchronous computation.

🔹 Returned by submitting a Callable to an ExecutorService.

🔹 Allows you to:

Get the result with get() (blocking call).

Cancel the task.

Check if the task is done.

ExecutorService executor = Executors.newFixedThreadPool(2);
Future<String> future = executor.submit(() -> "Result");
String result = future.get(); // waits for result
🧩 3. CompletableFuture
An enhancement over Future that supports non-blocking, chaining, and composition.

🔹 Part of Java 8+.

🔹 Supports:

supplyAsync() or runAsync() for async execution.

Callback chains: thenApply, thenAccept, thenCombine, etc.

Non-blocking execution: whenComplete, exceptionally, etc.

CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenApply(result -> result + " World");

future.thenAccept(System.out::println); // Prints: Hello World
🧩 4. ExecutorService
A thread pool manager that executes Runnable or Callable tasks asynchronously.

🔹 Provides thread reuse.

🔹 Avoids manual thread management (new Thread(...)).

🔹 You submit tasks, and it returns Future (for Callable) or void (for Runnable).

🔹 Must call shutdown() to stop accepting tasks and clean up.

ExecutorService executor = Executors.newFixedThreadPool(3);
executor.submit(() -> System.out.println("Task running"));
executor.shutdown();


| Use Case                                                              | Use This                                                                |
| --------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| Need to return a result from a background task                        | `Callable` + `Future`                                                   |
| Need to run async tasks and chain results or handle errors gracefully | `CompletableFuture`                                                     |
| Want to manage a thread pool and submit tasks                         | `ExecutorService`                                                       |
| Need fine-grained control over async task lifecycle                   | Combine `ExecutorService` with `Callable/Future` or `CompletableFuture` |




✅ Your Exercise:
Write a program that starts 5 threads.

Each thread should:

Print its name

Sleep for 500ms between prints

Repeat this 3 times

Would you like me to generate the solution for this challenge or would you like to try it and I’ll review?









Ask ChatGPT
